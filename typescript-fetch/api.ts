/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Official Assignee Service Information System v4 (OASIS4)
 * This version  (1.3.1) contains  - basic searches of the registers (plural)   - claims functionality   - contacts functionality  - a PLACEHOLDER for estates fucnionality which is NOT CANONICAL   
 *
 * OpenAPI spec version: 1.3.1
 * Contact: sam@pxp.nz
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/v1/oasis4".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * This is the detailed claim recource that is attached to 1 and only 1 estate. 
 * @export
 * @interface Address
 */
export interface Address {
}

/**
 * A claim that has in some stage of it's lifecycle been 'accepted' - this is the detailed claim recource that is attached to 1 and only 1^ estate.  ^ the edge / compensating case here is a linked claim - seet HATEOS links. 
 * @export
 * @interface ClaimRecord
 */
export interface ClaimRecord {
}

/**
 * A single claim search summary result
 * @export
 * @interface ClaimSearchResult
 */
export interface ClaimSearchResult {
}

/**
 * Paged collection of the results returned for an oasis search. 
 * @export
 * @interface ClaimSearchResults
 */
export interface ClaimSearchResults extends CollectionMetadata {
    /**
     * The search criteria
     * @type {string}
     * @memberof ClaimSearchResults
     */
    searchCriteria?: string;
    /**
     * The array of results
     * @type {Array&lt;ClaimSearchResult&gt;}
     * @memberof ClaimSearchResults
     */
    items?: Array<ClaimSearchResult>;
}

/**
 * @export
 * @namespace ClaimSearchResults
 */
export namespace ClaimSearchResults {
}

/**
 * Metadata associated with a paginated collection
 * @export
 * @interface CollectionMetadata
 */
export interface CollectionMetadata {
    /**
     * The property the collection is sorted on. This is optional and may not be supported by all collections 
     * @type {string}
     * @memberof CollectionMetadata
     */
    sortBy?: string;
    /**
     * The page in the collection
     * @type {number}
     * @memberof CollectionMetadata
     */
    page: number;
    /**
     * The order the collection is sorted in. This is optional and may not be supported by all collections. Valid values are 'asc', 'desc' 
     * @type {string}
     * @memberof CollectionMetadata
     */
    sortOrder?: CollectionMetadata.SortOrderEnum;
    /**
     * The total number of results/items in this collection
     * @type {number}
     * @memberof CollectionMetadata
     */
    totalItems: number;
    /**
     * The number of results/items returned per page of results
     * @type {number}
     * @memberof CollectionMetadata
     */
    pageSize: number;
    /**
     * The list of links to navigate this collection
     * @type {Array&lt;Link&gt;}
     * @memberof CollectionMetadata
     */
    links: Array<Link>;
    /**
     * The number of pages in the collection given the current pageSize.  Note this will have the value ceiling(totalItems / pageSize). 
     * @type {number}
     * @memberof CollectionMetadata
     */
    totalPages: number;
}

/**
 * @export
 * @namespace CollectionMetadata
 */
export namespace CollectionMetadata {
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}

/**
 * 
 * @export
 * @interface ContactName
 */
export interface ContactName {
    /**
     * 
     * @type {string}
     * @memberof ContactName
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactName
     */
    homePage?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactName
     */
    phone?: string;
}

/**
 * Contact search summary results - intended to be served from SOLR - the graphs returned by the SOLR service as part of the typeahead search.  
 * @export
 * @interface ContactSearchResult
 */
export interface ContactSearchResult {
}

/**
 * Paged collection of the results returned for an oasis contacts search. 
 * @export
 * @interface ContactSearchResults
 */
export interface ContactSearchResults extends CollectionMetadata {
    /**
     * The search criteria
     * @type {string}
     * @memberof ContactSearchResults
     */
    searchCriteria?: string;
    /**
     * The array of results
     * @type {Array&lt;ContactSearchResult&gt;}
     * @memberof ContactSearchResults
     */
    searchResults?: Array<ContactSearchResult>;
}

/**
 * @export
 * @namespace ContactSearchResults
 */
export namespace ContactSearchResults {
}

/**
 * Representation of generic error response
 * @export
 * @interface ErrorDescription
 */
export interface ErrorDescription {
    /**
     * 
     * @type {string}
     * @memberof ErrorDescription
     */
    errorMessage: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDescription
     */
    errorCode: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDescription
     */
    errorDescription?: string;
}

/**
 * 
 * @export
 * @interface EstateDetail
 */
export interface EstateDetail {
    /**
     * 
     * @type {string}
     * @memberof EstateDetail
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EstateDetail
     */
    homePage?: string;
    /**
     * 
     * @type {string}
     * @memberof EstateDetail
     */
    phone?: string;
}

/**
 * JSON representation of the ATOM pub link format
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * The rel attribute specifies the relationship between the current resource and the linked resource. 
     * @type {string}
     * @memberof Link
     */
    rel: string;
    /**
     * Specifies the URL of the resource the link goes to
     * @type {string}
     * @memberof Link
     */
    href: string;
    /**
     * Specifies the HTTP method used
     * @type {string}
     * @memberof Link
     */
    method: Link.MethodEnum;
}

/**
 * @export
 * @namespace Link
 */
export namespace Link {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        HEAD = <any> 'HEAD',
        GET = <any> 'GET',
        PUT = <any> 'PUT',
        POST = <any> 'POST',
        PATCH = <any> 'PATCH',
        DELETE = <any> 'DELETE'
    }
}

/**
 * The subset of the claim record that may be modified / maintained. 
 * @export
 * @interface MaintainClaimRecord
 */
export interface MaintainClaimRecord {
}

/**
 * The claim application record potentially contains many claims so... claimApplication is 1:n with claims. ___ **Business Rules** * *Rule 1:* This is an example ___ 
 * @export
 * @interface NewClaimApplication
 */
export interface NewClaimApplication {
    /**
     * The email address of the claimant. 
     * @type {string}
     * @memberof NewClaimApplication
     */
    creditorEmail?: string;
    /**
     * The primary identifier of a claim application.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    claimApplicationId?: number;
    /**
     * The creditor's reference to be used for this claim application.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    creditorReference?: string;
    /**
     * Notfication options - boolean preference for notification frequency. 
     * @type {boolean}
     * @memberof NewClaimApplication
     */
    notficationThreeMonthly?: boolean;
    /**
     * Notfication options - boolean preference for notification frequency. 
     * @type {string}
     * @memberof NewClaimApplication
     */
    notficationSixMonthly?: string;
    /**
     * Unknown 
     * @type {boolean}
     * @memberof NewClaimApplication
     */
    estateAdminComplete?: boolean;
    /**
     * Unknown 
     * @type {string}
     * @memberof NewClaimApplication
     */
    estateAdminReopened?: string;
    /**
     * Boolean used to determine the ultimate claim type & priority.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    outstandingAmountSecured?: string;
    /**
     * Notfication options - boolean preference for alert when a large claim is filed. 
     * @type {boolean}
     * @memberof NewClaimApplication
     */
    notificationFilingClaimLargeClaim?: boolean;
    /**
     * Adjudication and Accplication costs awarded by the courts. Boolean used to determine the ultimate claim type & priority.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    adjAppCosts?: string;
    /**
     * Boolean used to determine the ultimate claim type & priority.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    wagesHolidayPay?: string;
    /**
     * Boolean used to determine the claim type & priority.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    unpaidTaxesLevies?: string;
    /**
     * Boolean used to determine the claim type and priority.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    outstandingAmountNotSecured?: string;
    /**
     * Boolean indicating whether the claim is subject to court action, used to determine the claim type and priority.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    subjectToCourtActionYn?: string;
    /**
     * The userID that created the claim application.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    createdBy?: string;
    /**
     * The DateTime the claim application was created - cannot e specified in the request, comes from the header information.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    createdDate?: string;
    /**
     * The last user to update the claim application record.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    lastUpdatedBy?: string;
    /**
     * The full name of the user that last updated the claim application record, Cannot be specified but comes through from the logged in user.   ___ * PROPOSED TO REMOVE THIS  ___ 
     * @type {string}
     * @memberof NewClaimApplication
     */
    lastUpdatedByName?: string;
    /**
     * The version number of the claim application.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    version?: number;
    /**
     * If the claim is not filed by the actual claimant, the name of the person completeing the applciation. Note: this seems redundant as we already know who is logged in.   Question for Jenny: Shouldn't it be name of actual claimant?  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncPersonEnteringApp?: string;
    /**
     * Unknown. Appears to be roles, But also free text. Hard to say where this comes from.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncDesignation?: string;
    /**
     * The ammount claimed in relation to any adjudication / application costs for the estate  
     * @type {number}
     * @memberof NewClaimApplication
     */
    adjAppCostsAmountClaimed?: number;
    /**
     * The amount claimed, in words. Used as a manual checksum.   ___ * PROPOSED TO REMOVE THIS  ___ 
     * @type {string}
     * @memberof NewClaimApplication
     */
    adjAppCostsAmountClaimedInWords?: string;
    /**
     * Enum - how the evidence was provided. POS, FAX or DRM. Relating to Postal, Online attachment or Fax evidence.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncAppEvidenceCode?: string;
    /**
     * 
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncWagesAmountClaimed?: number;
    /**
     * 
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncWagesAmountInWords?: string;
    /**
     * The start for the time period for which wages are claimed.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncWagesFromDate?: string;
    /**
     * The end date for the tme period for which wages are claimed.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncWagesToDate?: string;
    /**
     * Description of the circumsances & particulars for the wages claim.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncWagesDescription?: string;
    /**
     * Enum:  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncWagesEvidenceCode?: string;
    /**
     * The amount claimed in relation to wages.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncTaxesAmountClaimed?: number;
    /**
     * The amount claimed in realtion to taxes owed, in words.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncTaxesAmountInWords?: string;
    /**
     * The GST content of the taxes owed.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncTaxesGstContent?: number;
    /**
     * The start date to which the tax claim relates.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncTaxesFromDate?: string;
    /**
     * THe end date to which the tax claim relates.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncTaxesToDate?: string;
    /**
     * A description of the Tax claim.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncTaxesDescription?: string;
    /**
     * Enum:  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncTaxesEvidenceCode?: string;
    /**
     * The amount claimed for other tpes of debt.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncOutAmountClaimed?: number;
    /**
     * T  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncOutAmountInWords?: string;
    /**
     * The GST content of claims under other in the claim application.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncOutGstContent?: number;
    /**
     * The srart date for claims under other.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncOutFromDate?: string;
    /**
     * The end datae for claims under other.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncOutToDate?: string;
    /**
     * Description of claims nder other.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncOutDescription?: string;
    /**
     * Enum  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncOutEvidenceCode?: string;
    /**
     * The value of securities claimed as part of the application.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncSecValue?: number;
    /**
     * 
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncSecValueInWords?: string;
    /**
     * Description of the securities claimed in the application.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncSecDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncSecEvidenceCode?: string;
    /**
     * Description of any court actions relation to any of the claims in the application.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCourtActionDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCoutActionCode?: string;
    /**
     * The link to the evidence of court action supplied with the applciation.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCourtActionEvidence?: string;
    /**
     * Boolean indicating whether the application includes court awarded interest or interest agreed in a contract.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncClaimIncludeInterestYn?: string;
    /**
     * Enum  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncInterestEvidenceCode?: string;
    /**
     * Currency code for??  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCurCode?: string;
    /**
     * Currency code for claims relating to tax.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCurCodeTaxes?: string;
    /**
     * Currency code for amounts relating to securities claimed.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCurCodeSecurity?: string;
    /**
     * Currency code relating to amounts clamed under other.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCurCodeOutstanding?: string;
    /**
     * The unique contact ID relating to the account that created the claim.  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncCttId?: number;
    /**
     * The key creditor id - MAP AS A MULTIPLE TO ABOVE RECORD  
     * @type {number}
     * @memberof NewClaimApplication
     */
    oncKcrId?: number;
    /**
     * The currency code for adjucicated or application costs.  
     * @type {string}
     * @memberof NewClaimApplication
     */
    oncCurCodeApp?: string;
}

/**
 * A claim is an assertion by a creditor that they are owed funds in an insolvency procedure. In order to be accepted into Trust Accounting a claim must be both substantiated and accepted.  
 * @export
 * @interface OldClaimApplication
 */
export interface OldClaimApplication {
    /**
     * 
     * @type {Array&lt;number&gt;}
     * @memberof OldClaimApplication
     */
    estates?: Array<number>;
    /**
     * The business service / the kind of process the debtor is going through. 
     * @type {string}
     * @memberof OldClaimApplication
     */
    insolvencyType?: string;
    /**
     * The name of the user / organision that filed this claim.
     * @type {string}
     * @memberof OldClaimApplication
     */
    createdName?: string;
    /**
     * The user name of the user that created the claim.
     * @type {string}
     * @memberof OldClaimApplication
     */
    createdBy?: string;
    /**
     * The loose type of claim - used to assist with determining priorty.
     * @type {string}
     * @memberof OldClaimApplication
     */
    applicationType?: OldClaimApplication.ApplicationTypeEnum;
    /**
     * The user name of the user that created the claim.
     * @type {string}
     * @memberof OldClaimApplication
     */
    claimDescription?: string;
}

/**
 * @export
 * @namespace OldClaimApplication
 */
export namespace OldClaimApplication {
    /**
     * @export
     * @enum {string}
     */
    export enum ApplicationTypeEnum {
        WagesHolidayPayOrRedundancy = <any> 'Wages, holiday pay or redundancy',
        CourtAwardedAdjudication = <any> 'Court awarded adjudication',
        UnpaidTaxesOrLevies = <any> 'Unpaid taxes or levies',
        SecuredDebt = <any> 'Secured debt',
        PartOfCurrentCourtAction = <any> 'Part of current court action',
        Interest = <any> 'Interest'
    }
}


/**
 * ClaimsApi - fetch parameter creator
 * @export
 */
export const ClaimsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ### Overview  Get result matching claim_number  **UC Mapping:** View Claim   **Operation:** Will retrieve and return a claim back in the correct context & path i.e.            /estates/{estate_number}/claims{claim_number} ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS Links 1. Where claim has not yet been vetted, admitted orwithdrawn ----       \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }    ] 
         * @summary Gets claim details given a specific claim_number
         * @param {number} claimNumber The unique claim number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimClaimNumberGet(claimNumber: number, options: any = {}): FetchArgs {
            // verify required parameter 'claimNumber' is not null or undefined
            if (claimNumber === null || claimNumber === undefined) {
                throw new RequiredError('claimNumber','Required parameter claimNumber was null or undefined when calling claimClaimNumberGet.');
            }
            const localVarPath = `/claim/{claim_number}`
                .replace(`{${"claim_number"}}`, encodeURIComponent(String(claimNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **UC Mapping:** Search claim Search the insolvency register for a claim. 
         * @summary Gets a search result of claims
         * @param {string} [businessService] The type of the insolvency procedure, leave blank for all
         * @param {string} [status] The state of the insolvency procedure, leave blank for all
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimsGet(businessService?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/claims`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (businessService !== undefined) {
                localVarQueryParameter['businessService'] = businessService;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort-order'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort-by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
         * @summary Gets a search result of claims
         * @param {string} contactId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsContactIdClaimsGet(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId','Required parameter contactId was null or undefined when calling contactsContactIdClaimsGet.');
            }
            const localVarPath = `/contacts/{contact_id}/claims`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **UC Map:** Create Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a cliam application or a potential claim first. 
         * @summary Creates a new claim against the insolvent estate
         * @param {number} estateNumber The unique estate number of the insolvency 
         * @param {ClaimRecord} claimDetail The detail of the new claim record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClaim(estateNumber: number, claimDetail: ClaimRecord, options: any = {}): FetchArgs {
            // verify required parameter 'estateNumber' is not null or undefined
            if (estateNumber === null || estateNumber === undefined) {
                throw new RequiredError('estateNumber','Required parameter estateNumber was null or undefined when calling createClaim.');
            }
            // verify required parameter 'claimDetail' is not null or undefined
            if (claimDetail === null || claimDetail === undefined) {
                throw new RequiredError('claimDetail','Required parameter claimDetail was null or undefined when calling createClaim.');
            }
            const localVarPath = `/estates/{estate_number}/claims/`
                .replace(`{${"estate_number"}}`, encodeURIComponent(String(estateNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(claimDetail || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ### Overview  **UC Mapping:** ...  **Description:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
         * @summary Gets a search result of claims
         * @param {string} estateNumber * The unique identifier for the estate. 
         * @param {string} claimNumber * The unique identifier for the claim. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estatesEstateNumberClaimsClaimNumberGet(estateNumber: string, claimNumber: string, options: any = {}): FetchArgs {
            // verify required parameter 'estateNumber' is not null or undefined
            if (estateNumber === null || estateNumber === undefined) {
                throw new RequiredError('estateNumber','Required parameter estateNumber was null or undefined when calling estatesEstateNumberClaimsClaimNumberGet.');
            }
            // verify required parameter 'claimNumber' is not null or undefined
            if (claimNumber === null || claimNumber === undefined) {
                throw new RequiredError('claimNumber','Required parameter claimNumber was null or undefined when calling estatesEstateNumberClaimsClaimNumberGet.');
            }
            const localVarPath = `/estates/{estate_number}/claims/{claim_number}`
                .replace(`{${"estate_number"}}`, encodeURIComponent(String(estateNumber)))
                .replace(`{${"claim_number"}}`, encodeURIComponent(String(claimNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **UC Map:** Maintain Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a claim application or a potential claim first. 
         * @summary Maintains / modifies an existing claim
         * @param {number} estateNumber The unique identifier of the insolvency estate resource. 
         * @param {string} claimNumber * The unique identifier for the claim. 
         * @param {MaintainClaimRecord} claimDetail The detail of the value(s) to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        maintainClaim(estateNumber: number, claimNumber: string, claimDetail: MaintainClaimRecord, options: any = {}): FetchArgs {
            // verify required parameter 'estateNumber' is not null or undefined
            if (estateNumber === null || estateNumber === undefined) {
                throw new RequiredError('estateNumber','Required parameter estateNumber was null or undefined when calling maintainClaim.');
            }
            // verify required parameter 'claimNumber' is not null or undefined
            if (claimNumber === null || claimNumber === undefined) {
                throw new RequiredError('claimNumber','Required parameter claimNumber was null or undefined when calling maintainClaim.');
            }
            // verify required parameter 'claimDetail' is not null or undefined
            if (claimDetail === null || claimDetail === undefined) {
                throw new RequiredError('claimDetail','Required parameter claimDetail was null or undefined when calling maintainClaim.');
            }
            const localVarPath = `/estates/{estate_number}/claims/{claim_number}/maintain`
                .replace(`{${"estate_number"}}`, encodeURIComponent(String(estateNumber)))
                .replace(`{${"claim_number"}}`, encodeURIComponent(String(claimNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(claimDetail || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ### Overview  **UC Mapping:** View Claim  Get result matching estate_number ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | New claim | Where claim has not yet been vetted, admitted or withdrawn |   **1. New Claim**         \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }      ] 
         * @summary Returns for all claims associated to the current estate
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEstateClaims(page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/estates/{estate_number}/claims/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort-order'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort-by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClaimsApi - functional programming interface
 * @export
 */
export const ClaimsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ### Overview  Get result matching claim_number  **UC Mapping:** View Claim   **Operation:** Will retrieve and return a claim back in the correct context & path i.e.            /estates/{estate_number}/claims{claim_number} ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS Links 1. Where claim has not yet been vetted, admitted orwithdrawn ----       \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }    ] 
         * @summary Gets claim details given a specific claim_number
         * @param {number} claimNumber The unique claim number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimClaimNumberGet(claimNumber: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClaimRecord> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).claimClaimNumberGet(claimNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **UC Mapping:** Search claim Search the insolvency register for a claim. 
         * @summary Gets a search result of claims
         * @param {string} [businessService] The type of the insolvency procedure, leave blank for all
         * @param {string} [status] The state of the insolvency procedure, leave blank for all
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimsGet(businessService?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClaimSearchResults> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).claimsGet(businessService, status, page, pageSize, sortOrder, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
         * @summary Gets a search result of claims
         * @param {string} contactId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsContactIdClaimsGet(contactId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactSearchResults> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).contactsContactIdClaimsGet(contactId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **UC Map:** Create Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a cliam application or a potential claim first. 
         * @summary Creates a new claim against the insolvent estate
         * @param {number} estateNumber The unique estate number of the insolvency 
         * @param {ClaimRecord} claimDetail The detail of the new claim record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClaim(estateNumber: number, claimDetail: ClaimRecord, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClaimRecord> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).createClaim(estateNumber, claimDetail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * ### Overview  **UC Mapping:** ...  **Description:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
         * @summary Gets a search result of claims
         * @param {string} estateNumber * The unique identifier for the estate. 
         * @param {string} claimNumber * The unique identifier for the claim. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estatesEstateNumberClaimsClaimNumberGet(estateNumber: string, claimNumber: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClaimRecord> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).estatesEstateNumberClaimsClaimNumberGet(estateNumber, claimNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **UC Map:** Maintain Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a claim application or a potential claim first. 
         * @summary Maintains / modifies an existing claim
         * @param {number} estateNumber The unique identifier of the insolvency estate resource. 
         * @param {string} claimNumber * The unique identifier for the claim. 
         * @param {MaintainClaimRecord} claimDetail The detail of the value(s) to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        maintainClaim(estateNumber: number, claimNumber: string, claimDetail: MaintainClaimRecord, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClaimRecord> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).maintainClaim(estateNumber, claimNumber, claimDetail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * ### Overview  **UC Mapping:** View Claim  Get result matching estate_number ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | New claim | Where claim has not yet been vetted, admitted or withdrawn |   **1. New Claim**         \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }      ] 
         * @summary Returns for all claims associated to the current estate
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEstateClaims(page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClaimSearchResults> {
            const localVarFetchArgs = ClaimsApiFetchParamCreator(configuration).searchEstateClaims(page, pageSize, sortOrder, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClaimsApi - factory interface
 * @export
 */
export const ClaimsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * ### Overview  Get result matching claim_number  **UC Mapping:** View Claim   **Operation:** Will retrieve and return a claim back in the correct context & path i.e.            /estates/{estate_number}/claims{claim_number} ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS Links 1. Where claim has not yet been vetted, admitted orwithdrawn ----       \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }    ] 
         * @summary Gets claim details given a specific claim_number
         * @param {number} claimNumber The unique claim number 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimClaimNumberGet(claimNumber: number, options?: any) {
            return ClaimsApiFp(configuration).claimClaimNumberGet(claimNumber, options)(fetch, basePath);
        },
        /**
         * **UC Mapping:** Search claim Search the insolvency register for a claim. 
         * @summary Gets a search result of claims
         * @param {string} [businessService] The type of the insolvency procedure, leave blank for all
         * @param {string} [status] The state of the insolvency procedure, leave blank for all
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimsGet(businessService?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
            return ClaimsApiFp(configuration).claimsGet(businessService, status, page, pageSize, sortOrder, sortBy, options)(fetch, basePath);
        },
        /**
         * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
         * @summary Gets a search result of claims
         * @param {string} contactId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsContactIdClaimsGet(contactId: string, options?: any) {
            return ClaimsApiFp(configuration).contactsContactIdClaimsGet(contactId, options)(fetch, basePath);
        },
        /**
         * **UC Map:** Create Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a cliam application or a potential claim first. 
         * @summary Creates a new claim against the insolvent estate
         * @param {number} estateNumber The unique estate number of the insolvency 
         * @param {ClaimRecord} claimDetail The detail of the new claim record.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClaim(estateNumber: number, claimDetail: ClaimRecord, options?: any) {
            return ClaimsApiFp(configuration).createClaim(estateNumber, claimDetail, options)(fetch, basePath);
        },
        /**
         * ### Overview  **UC Mapping:** ...  **Description:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
         * @summary Gets a search result of claims
         * @param {string} estateNumber * The unique identifier for the estate. 
         * @param {string} claimNumber * The unique identifier for the claim. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estatesEstateNumberClaimsClaimNumberGet(estateNumber: string, claimNumber: string, options?: any) {
            return ClaimsApiFp(configuration).estatesEstateNumberClaimsClaimNumberGet(estateNumber, claimNumber, options)(fetch, basePath);
        },
        /**
         * **UC Map:** Maintain Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a claim application or a potential claim first. 
         * @summary Maintains / modifies an existing claim
         * @param {number} estateNumber The unique identifier of the insolvency estate resource. 
         * @param {string} claimNumber * The unique identifier for the claim. 
         * @param {MaintainClaimRecord} claimDetail The detail of the value(s) to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        maintainClaim(estateNumber: number, claimNumber: string, claimDetail: MaintainClaimRecord, options?: any) {
            return ClaimsApiFp(configuration).maintainClaim(estateNumber, claimNumber, claimDetail, options)(fetch, basePath);
        },
        /**
         * ### Overview  **UC Mapping:** View Claim  Get result matching estate_number ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | New claim | Where claim has not yet been vetted, admitted or withdrawn |   **1. New Claim**         \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }      ] 
         * @summary Returns for all claims associated to the current estate
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEstateClaims(page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
            return ClaimsApiFp(configuration).searchEstateClaims(page, pageSize, sortOrder, sortBy, options)(fetch, basePath);
        },
    };
};

/**
 * ClaimsApi - object-oriented interface
 * @export
 * @class ClaimsApi
 * @extends {BaseAPI}
 */
export class ClaimsApi extends BaseAPI {
    /**
     * ### Overview  Get result matching claim_number  **UC Mapping:** View Claim   **Operation:** Will retrieve and return a claim back in the correct context & path i.e.            /estates/{estate_number}/claims{claim_number} ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS Links 1. Where claim has not yet been vetted, admitted orwithdrawn ----       \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }    ] 
     * @summary Gets claim details given a specific claim_number
     * @param {} claimNumber The unique claim number 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public claimClaimNumberGet(claimNumber: number, options?: any) {
        return ClaimsApiFp(this.configuration).claimClaimNumberGet(claimNumber, options)(this.fetch, this.basePath);
    }

    /**
     * **UC Mapping:** Search claim Search the insolvency register for a claim. 
     * @summary Gets a search result of claims
     * @param {} [businessService] The type of the insolvency procedure, leave blank for all
     * @param {} [status] The state of the insolvency procedure, leave blank for all
     * @param {} [page] The page in the collection to return. Default is page 1.
     * @param {} [pageSize] The requested number of items to include in each page returned. Default is 20. 
     * @param {} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
     * @param {} [sortBy] The property to sort the collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public claimsGet(businessService?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
        return ClaimsApiFp(this.configuration).claimsGet(businessService, status, page, pageSize, sortOrder, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
     * @summary Gets a search result of claims
     * @param {} contactId * The unique identifier for the contact. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public contactsContactIdClaimsGet(contactId: string, options?: any) {
        return ClaimsApiFp(this.configuration).contactsContactIdClaimsGet(contactId, options)(this.fetch, this.basePath);
    }

    /**
     * **UC Map:** Create Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a cliam application or a potential claim first. 
     * @summary Creates a new claim against the insolvent estate
     * @param {} estateNumber The unique estate number of the insolvency 
     * @param {} claimDetail The detail of the new claim record.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public createClaim(estateNumber: number, claimDetail: ClaimRecord, options?: any) {
        return ClaimsApiFp(this.configuration).createClaim(estateNumber, claimDetail, options)(this.fetch, this.basePath);
    }

    /**
     * ### Overview  **UC Mapping:** ...  **Description:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
     * @summary Gets a search result of claims
     * @param {} estateNumber * The unique identifier for the estate. 
     * @param {} claimNumber * The unique identifier for the claim. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public estatesEstateNumberClaimsClaimNumberGet(estateNumber: string, claimNumber: string, options?: any) {
        return ClaimsApiFp(this.configuration).estatesEstateNumberClaimsClaimNumberGet(estateNumber, claimNumber, options)(this.fetch, this.basePath);
    }

    /**
     * **UC Map:** Maintain Claim  Creates a new claim against an estate - can only be done by an insolvency officer - claims from other participants need to be vetted and accepted - goeing throught the embryonic stage of being a claim application or a potential claim first. 
     * @summary Maintains / modifies an existing claim
     * @param {} estateNumber The unique identifier of the insolvency estate resource. 
     * @param {} claimNumber * The unique identifier for the claim. 
     * @param {} claimDetail The detail of the value(s) to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public maintainClaim(estateNumber: number, claimNumber: string, claimDetail: MaintainClaimRecord, options?: any) {
        return ClaimsApiFp(this.configuration).maintainClaim(estateNumber, claimNumber, claimDetail, options)(this.fetch, this.basePath);
    }

    /**
     * ### Overview  **UC Mapping:** View Claim  Get result matching estate_number ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * The ringfence area has been checked * Individual permissions have been checked * The claim record is returned if it exists    * An audit record for the read has been created (asynchronously) in mongoDB  ____ ### --- Error messages --- | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | New claim | Where claim has not yet been vetted, admitted or withdrawn |   **1. New Claim**         \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims,\",        \"rel\": \"claim.search,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682,\",        \"rel\": \"claim.maintain,\",        \"method\": \"PUT\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/suspend,\",        \"rel\": \"claim.suspend,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/vet,\",        \"rel\": \"claim.vet,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/admit,\",        \"rel\": \"claim.admit,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/reject,\",        \"rel\": \"claim.reject,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets,\",        \"rel\": \"claim.assets,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/assets/523623/link,\",        \"rel\": \"claim.assets.link,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/folios,\",        \"rel\": \"claim.folios,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_folio,\",        \"rel\": \"claim.link.folio,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/link_claim,\",        \"rel\": \"claim.link.claim,\",        \"method\": \"POST\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history,\",        \"rel\": \"claim.history,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/history/64,\",        \"rel\": \"claim.view_history_record,\",        \"method\": \"GET\"      },      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/estates/883785/claims/4855682/audit_log,\",        \"rel\": \"claim.search_audit,\",        \"method\": \"GET\"      }      ] 
     * @summary Returns for all claims associated to the current estate
     * @param {} [page] The page in the collection to return. Default is page 1.
     * @param {} [pageSize] The requested number of items to include in each page returned. Default is 20. 
     * @param {} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
     * @param {} [sortBy] The property to sort the collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClaimsApi
     */
    public searchEstateClaims(page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
        return ClaimsApiFp(this.configuration).searchEstateClaims(page, pageSize, sortOrder, sortBy, options)(this.fetch, this.basePath);
    }

}

/**
 * ContactsApi - fetch parameter creator
 * @export
 */
export const ContactsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
         * @summary Gets a search result of claims
         * @param {string} contactId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsContactIdClaimsGet(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId','Required parameter contactId was null or undefined when calling contactsContactIdClaimsGet.');
            }
            const localVarPath = `/contacts/{contact_id}/claims`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Search the insolvency & SIO registers for a contact.**   * Objective is to avoid duplication & encourage re-use   * Aid positive identification   * UX-UI flows should make it harder to create a contact than to re-use one    **NOTES FOR SEARCH INDEX POPULATION:**   * Aliases and names should be peers in terms of search, with a minor prefereence given to a primary name where there are multiple matches   * Contact name should be returned next to alias in search result string(s)   * Index to return a **graph** of contacts (people), phone numbers, addresses, and organisations associated to the contact       * Contact to contact graph       * Address to contact graph       * Company to contact graph       * Phone number to contact graph        **Intended behaviour:** it is intended that this functionality be used to implement typeahead searches possibly as a single search combo box - *in the short term it is possibly simpler but a lot less elegant and a lot less fun to implement as multiple typeaheads*.          --- SOME SEARCH PARAMETERS NOT IMPLEMENTED ---         The following booleans have not been carried over into this design:         * Show all addresses         * Withhold         * Main contact         * Protect from edit         
         * @summary Gets a search result of contacts (may be people or organisations).
         * @param {string} [addresses] **Single search combo box for:** * Physical &amp; Postal Addresses (only those populated against a contact - not all of PAF / NZAD)   *__Traceability to existing earch parameters:__*   * Street Name   * Region   * Suburb   * Country   * City / Town * Email addresses (in use on a contact) * Social media addresses (in use on a contact) * Phone numbers 
         * @param {string} [names] * Searches **both** primary contact and alias records. * Ideally implemented as typeahead  **Traceability to current search:** This parameter is intended to implement all of the following existing search parameters... * Last Name * First Name * Middle Name(s) * Organisation Name  and, in addition, should search any associated aliases for these same fields. 
         * @param {boolean} [excludeNotInUse] * Excludes contacts that are not in use (so; not associated to an estate) from the scope of the search. 
         * @param {boolean} [excludeBranches] * Excludes branches from the scope of the search. 
         * @param {boolean} [excludeAlternate] * Excludes aliases and secondary addresses from the scope of the search. * Very bad idea, would like to deprecate if possible. 
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(addresses?: string, names?: string, excludeNotInUse?: boolean, excludeBranches?: boolean, excludeAlternate?: boolean, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (addresses !== undefined) {
                localVarQueryParameter['addresses'] = addresses;
            }

            if (names !== undefined) {
                localVarQueryParameter['names'] = names;
            }

            if (excludeNotInUse !== undefined) {
                localVarQueryParameter['excludeNotInUse'] = excludeNotInUse;
            }

            if (excludeBranches !== undefined) {
                localVarQueryParameter['excludeBranches'] = excludeBranches;
            }

            if (excludeAlternate !== undefined) {
                localVarQueryParameter['excludeAlternate'] = excludeAlternate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort-order'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort-by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
         * @summary Gets a search result of claims
         * @param {string} contactId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsContactIdClaimsGet(contactId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactSearchResults> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).contactsContactIdClaimsGet(contactId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Search the insolvency & SIO registers for a contact.**   * Objective is to avoid duplication & encourage re-use   * Aid positive identification   * UX-UI flows should make it harder to create a contact than to re-use one    **NOTES FOR SEARCH INDEX POPULATION:**   * Aliases and names should be peers in terms of search, with a minor prefereence given to a primary name where there are multiple matches   * Contact name should be returned next to alias in search result string(s)   * Index to return a **graph** of contacts (people), phone numbers, addresses, and organisations associated to the contact       * Contact to contact graph       * Address to contact graph       * Company to contact graph       * Phone number to contact graph        **Intended behaviour:** it is intended that this functionality be used to implement typeahead searches possibly as a single search combo box - *in the short term it is possibly simpler but a lot less elegant and a lot less fun to implement as multiple typeaheads*.          --- SOME SEARCH PARAMETERS NOT IMPLEMENTED ---         The following booleans have not been carried over into this design:         * Show all addresses         * Withhold         * Main contact         * Protect from edit         
         * @summary Gets a search result of contacts (may be people or organisations).
         * @param {string} [addresses] **Single search combo box for:** * Physical &amp; Postal Addresses (only those populated against a contact - not all of PAF / NZAD)   *__Traceability to existing earch parameters:__*   * Street Name   * Region   * Suburb   * Country   * City / Town * Email addresses (in use on a contact) * Social media addresses (in use on a contact) * Phone numbers 
         * @param {string} [names] * Searches **both** primary contact and alias records. * Ideally implemented as typeahead  **Traceability to current search:** This parameter is intended to implement all of the following existing search parameters... * Last Name * First Name * Middle Name(s) * Organisation Name  and, in addition, should search any associated aliases for these same fields. 
         * @param {boolean} [excludeNotInUse] * Excludes contacts that are not in use (so; not associated to an estate) from the scope of the search. 
         * @param {boolean} [excludeBranches] * Excludes branches from the scope of the search. 
         * @param {boolean} [excludeAlternate] * Excludes aliases and secondary addresses from the scope of the search. * Very bad idea, would like to deprecate if possible. 
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(addresses?: string, names?: string, excludeNotInUse?: boolean, excludeBranches?: boolean, excludeAlternate?: boolean, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactSearchResults> {
            const localVarFetchArgs = ContactsApiFetchParamCreator(configuration).contactsGet(addresses, names, excludeNotInUse, excludeBranches, excludeAlternate, page, pageSize, sortOrder, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
         * @summary Gets a search result of claims
         * @param {string} contactId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsContactIdClaimsGet(contactId: string, options?: any) {
            return ContactsApiFp(configuration).contactsContactIdClaimsGet(contactId, options)(fetch, basePath);
        },
        /**
         * **Search the insolvency & SIO registers for a contact.**   * Objective is to avoid duplication & encourage re-use   * Aid positive identification   * UX-UI flows should make it harder to create a contact than to re-use one    **NOTES FOR SEARCH INDEX POPULATION:**   * Aliases and names should be peers in terms of search, with a minor prefereence given to a primary name where there are multiple matches   * Contact name should be returned next to alias in search result string(s)   * Index to return a **graph** of contacts (people), phone numbers, addresses, and organisations associated to the contact       * Contact to contact graph       * Address to contact graph       * Company to contact graph       * Phone number to contact graph        **Intended behaviour:** it is intended that this functionality be used to implement typeahead searches possibly as a single search combo box - *in the short term it is possibly simpler but a lot less elegant and a lot less fun to implement as multiple typeaheads*.          --- SOME SEARCH PARAMETERS NOT IMPLEMENTED ---         The following booleans have not been carried over into this design:         * Show all addresses         * Withhold         * Main contact         * Protect from edit         
         * @summary Gets a search result of contacts (may be people or organisations).
         * @param {string} [addresses] **Single search combo box for:** * Physical &amp; Postal Addresses (only those populated against a contact - not all of PAF / NZAD)   *__Traceability to existing earch parameters:__*   * Street Name   * Region   * Suburb   * Country   * City / Town * Email addresses (in use on a contact) * Social media addresses (in use on a contact) * Phone numbers 
         * @param {string} [names] * Searches **both** primary contact and alias records. * Ideally implemented as typeahead  **Traceability to current search:** This parameter is intended to implement all of the following existing search parameters... * Last Name * First Name * Middle Name(s) * Organisation Name  and, in addition, should search any associated aliases for these same fields. 
         * @param {boolean} [excludeNotInUse] * Excludes contacts that are not in use (so; not associated to an estate) from the scope of the search. 
         * @param {boolean} [excludeBranches] * Excludes branches from the scope of the search. 
         * @param {boolean} [excludeAlternate] * Excludes aliases and secondary addresses from the scope of the search. * Very bad idea, would like to deprecate if possible. 
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGet(addresses?: string, names?: string, excludeNotInUse?: boolean, excludeBranches?: boolean, excludeAlternate?: boolean, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
            return ContactsApiFp(configuration).contactsGet(addresses, names, excludeNotInUse, excludeBranches, excludeAlternate, page, pageSize, sortOrder, sortBy, options)(fetch, basePath);
        },
    };
};

/**
 * ContactsApi - object-oriented interface
 * @export
 * @class ContactsApi
 * @extends {BaseAPI}
 */
export class ContactsApi extends BaseAPI {
    /**
     * **UC Mapping:** List Claims  ___ List the claims associated with an individual system user. 
     * @summary Gets a search result of claims
     * @param {} contactId * The unique identifier for the contact. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsContactIdClaimsGet(contactId: string, options?: any) {
        return ContactsApiFp(this.configuration).contactsContactIdClaimsGet(contactId, options)(this.fetch, this.basePath);
    }

    /**
     * **Search the insolvency & SIO registers for a contact.**   * Objective is to avoid duplication & encourage re-use   * Aid positive identification   * UX-UI flows should make it harder to create a contact than to re-use one    **NOTES FOR SEARCH INDEX POPULATION:**   * Aliases and names should be peers in terms of search, with a minor prefereence given to a primary name where there are multiple matches   * Contact name should be returned next to alias in search result string(s)   * Index to return a **graph** of contacts (people), phone numbers, addresses, and organisations associated to the contact       * Contact to contact graph       * Address to contact graph       * Company to contact graph       * Phone number to contact graph        **Intended behaviour:** it is intended that this functionality be used to implement typeahead searches possibly as a single search combo box - *in the short term it is possibly simpler but a lot less elegant and a lot less fun to implement as multiple typeaheads*.          --- SOME SEARCH PARAMETERS NOT IMPLEMENTED ---         The following booleans have not been carried over into this design:         * Show all addresses         * Withhold         * Main contact         * Protect from edit         
     * @summary Gets a search result of contacts (may be people or organisations).
     * @param {} [addresses] **Single search combo box for:** * Physical &amp; Postal Addresses (only those populated against a contact - not all of PAF / NZAD)   *__Traceability to existing earch parameters:__*   * Street Name   * Region   * Suburb   * Country   * City / Town * Email addresses (in use on a contact) * Social media addresses (in use on a contact) * Phone numbers 
     * @param {} [names] * Searches **both** primary contact and alias records. * Ideally implemented as typeahead  **Traceability to current search:** This parameter is intended to implement all of the following existing search parameters... * Last Name * First Name * Middle Name(s) * Organisation Name  and, in addition, should search any associated aliases for these same fields. 
     * @param {} [excludeNotInUse] * Excludes contacts that are not in use (so; not associated to an estate) from the scope of the search. 
     * @param {} [excludeBranches] * Excludes branches from the scope of the search. 
     * @param {} [excludeAlternate] * Excludes aliases and secondary addresses from the scope of the search. * Very bad idea, would like to deprecate if possible. 
     * @param {} [page] The page in the collection to return. Default is page 1.
     * @param {} [pageSize] The requested number of items to include in each page returned. Default is 20. 
     * @param {} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
     * @param {} [sortBy] The property to sort the collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApi
     */
    public contactsGet(addresses?: string, names?: string, excludeNotInUse?: boolean, excludeBranches?: boolean, excludeAlternate?: boolean, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
        return ContactsApiFp(this.configuration).contactsGet(addresses, names, excludeNotInUse, excludeBranches, excludeAlternate, page, pageSize, sortOrder, sortBy, options)(this.fetch, this.basePath);
    }

}

/**
 * EstatesApi - fetch parameter creator
 * @export
 */
export const EstatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By passing in the estate_number, the details of the estate are returned 
         * @summary ---- PLACEHOLDER ---- Gets details of the insolvent estate
         * @param {number} estateNumber The unique estate number of the insolvency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateDetails(estateNumber: number, options: any = {}): FetchArgs {
            // verify required parameter 'estateNumber' is not null or undefined
            if (estateNumber === null || estateNumber === undefined) {
                throw new RequiredError('estateNumber','Required parameter estateNumber was null or undefined when calling getEstateDetails.');
            }
            const localVarPath = `/estates/{estate_number}`
                .replace(`{${"estate_number"}}`, encodeURIComponent(String(estateNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search the insolvency register for a bunkrupt (current or discharged) person Question: do I need to split into SIO and Insolvency search 
         * @summary ---- PLACEHOLDER ---- Gets a search result of Insolvencies
         * @param {string} [surname] Surname of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [middleName] Middle name of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [firstName] First Name of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [status] The status of the Insolvency, leave blank for all
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEstates(surname?: string, middleName?: string, firstName?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/estates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (surname !== undefined) {
                localVarQueryParameter['surname'] = surname;
            }

            if (middleName !== undefined) {
                localVarQueryParameter['middle-name'] = middleName;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first-name'] = firstName;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page-size'] = pageSize;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort-order'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort-by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EstatesApi - functional programming interface
 * @export
 */
export const EstatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * By passing in the estate_number, the details of the estate are returned 
         * @summary ---- PLACEHOLDER ---- Gets details of the insolvent estate
         * @param {number} estateNumber The unique estate number of the insolvency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateDetails(estateNumber: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EstateDetail> {
            const localVarFetchArgs = EstatesApiFetchParamCreator(configuration).getEstateDetails(estateNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search the insolvency register for a bunkrupt (current or discharged) person Question: do I need to split into SIO and Insolvency search 
         * @summary ---- PLACEHOLDER ---- Gets a search result of Insolvencies
         * @param {string} [surname] Surname of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [middleName] Middle name of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [firstName] First Name of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [status] The status of the Insolvency, leave blank for all
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEstates(surname?: string, middleName?: string, firstName?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EstatesApiFetchParamCreator(configuration).searchEstates(surname, middleName, firstName, status, page, pageSize, sortOrder, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EstatesApi - factory interface
 * @export
 */
export const EstatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * By passing in the estate_number, the details of the estate are returned 
         * @summary ---- PLACEHOLDER ---- Gets details of the insolvent estate
         * @param {number} estateNumber The unique estate number of the insolvency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstateDetails(estateNumber: number, options?: any) {
            return EstatesApiFp(configuration).getEstateDetails(estateNumber, options)(fetch, basePath);
        },
        /**
         * Search the insolvency register for a bunkrupt (current or discharged) person Question: do I need to split into SIO and Insolvency search 
         * @summary ---- PLACEHOLDER ---- Gets a search result of Insolvencies
         * @param {string} [surname] Surname of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [middleName] Middle name of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [firstName] First Name of the Bankrupt Person (requires one name to be searched) 
         * @param {string} [status] The status of the Insolvency, leave blank for all
         * @param {number} [page] The page in the collection to return. Default is page 1.
         * @param {number} [pageSize] The requested number of items to include in each page returned. Default is 20. 
         * @param {string} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
         * @param {string} [sortBy] The property to sort the collection by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEstates(surname?: string, middleName?: string, firstName?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
            return EstatesApiFp(configuration).searchEstates(surname, middleName, firstName, status, page, pageSize, sortOrder, sortBy, options)(fetch, basePath);
        },
    };
};

/**
 * EstatesApi - object-oriented interface
 * @export
 * @class EstatesApi
 * @extends {BaseAPI}
 */
export class EstatesApi extends BaseAPI {
    /**
     * By passing in the estate_number, the details of the estate are returned 
     * @summary ---- PLACEHOLDER ---- Gets details of the insolvent estate
     * @param {} estateNumber The unique estate number of the insolvency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstatesApi
     */
    public getEstateDetails(estateNumber: number, options?: any) {
        return EstatesApiFp(this.configuration).getEstateDetails(estateNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Search the insolvency register for a bunkrupt (current or discharged) person Question: do I need to split into SIO and Insolvency search 
     * @summary ---- PLACEHOLDER ---- Gets a search result of Insolvencies
     * @param {} [surname] Surname of the Bankrupt Person (requires one name to be searched) 
     * @param {} [middleName] Middle name of the Bankrupt Person (requires one name to be searched) 
     * @param {} [firstName] First Name of the Bankrupt Person (requires one name to be searched) 
     * @param {} [status] The status of the Insolvency, leave blank for all
     * @param {} [page] The page in the collection to return. Default is page 1.
     * @param {} [pageSize] The requested number of items to include in each page returned. Default is 20. 
     * @param {} [sortOrder] The order to sort the collection in. Can be &#39;asc&#39; or &#39;desc&#39;.
     * @param {} [sortBy] The property to sort the collection by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EstatesApi
     */
    public searchEstates(surname?: string, middleName?: string, firstName?: string, status?: string, page?: number, pageSize?: number, sortOrder?: string, sortBy?: string, options?: any) {
        return EstatesApiFp(this.configuration).searchEstates(surname, middleName, firstName, status, page, pageSize, sortOrder, sortBy, options)(this.fetch, this.basePath);
    }

}

/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
export const TemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ### Overview  **UC Mapping:** ...  **Operation:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
         * @summary Gets a search result of claims
         * @param {string} someId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateSomeIdResourceGet(someId: string, options: any = {}): FetchArgs {
            // verify required parameter 'someId' is not null or undefined
            if (someId === null || someId === undefined) {
                throw new RequiredError('someId','Required parameter someId was null or undefined when calling templateSomeIdResourceGet.');
            }
            const localVarPath = `/template/{some_id}/resource`
                .replace(`{${"some_id"}}`, encodeURIComponent(String(someId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ### Overview  **UC Mapping:** ...  **Operation:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
         * @summary Gets a search result of claims
         * @param {string} someId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateSomeIdResourceGet(someId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ContactSearchResults> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).templateSomeIdResourceGet(someId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * ### Overview  **UC Mapping:** ...  **Operation:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
         * @summary Gets a search result of claims
         * @param {string} someId * The unique identifier for the contact. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateSomeIdResourceGet(someId: string, options?: any) {
            return TemplatesApiFp(configuration).templateSomeIdResourceGet(someId, options)(fetch, basePath);
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * ### Overview  **UC Mapping:** ...  **Operation:** ....  ____ ### Pre-conditions * User is authenticated ____ ### Post-conditions * ... * ... ____ ### Error messages | Code| Message | Description| |----|-----|------| | **400** | Not authenticated | Agent not authenticated |  ### HATEOAS \"links\" element examples | Num | Case | Description / Rules | |----|-----|------| | **1** | ... | ... |   **Case 1**       {      \"links\": [      {        \"href\": \"https://app.insolvency.govt.nz/v1/oasis4/.../883785/.../4855682,\",        \"rel\": \"self,\",        \"method\": \"GET\"      }      ]       
     * @summary Gets a search result of claims
     * @param {} someId * The unique identifier for the contact. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templateSomeIdResourceGet(someId: string, options?: any) {
        return TemplatesApiFp(this.configuration).templateSomeIdResourceGet(someId, options)(this.fetch, this.basePath);
    }

}

